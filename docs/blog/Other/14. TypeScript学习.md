# 14. TypeScript学习

TypeScript 是 JavaScript 的一个超集，主要提供了**类型系统**和**对 ES6 的支持**，它由 Microsoft 开发。


## 基础
### 1. 原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。
```ts
let isDone: boolean = false;

let anyThing: any = 'hello';//任意值（未指定其类型，那么它会被识别为任意值类型）

function getLength(something: string | number): number {
    return something.length;
}
```
### 2. 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：
```ts
function alertName(): void {
  alert('My name is Tom');
}

let unusable: void = undefined;
```
### 3. undefined 和 null 是所有类型的子类型：
```ts
// 这样不会报错
let num: number = undefined;
```
### 4. 类型推论
```ts
let myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.

let myFavoriteNumber;//设为any类型
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
```
### 5. 联合类型
```ts
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
```
### 6. 接口（Interfaces）是一个很重要的概念，它是对行为的抽象：
```ts
//不能新增也不能缺少属性
interface Person {
    name: string;
    age: number;
}
let tom: Person = {
    name: 'Tom',
    age: 25
};

//可以缺少age
interface Person {
    name: string;
    age?: number;
}
let tom: Person = {
    name: 'Tom'
};

//任意属性
interface Person {
    name: string;
    age?: number;
    run(): void;
    [propName: string]: any;
}
let tom: Person = {
    name: 'Tom',
    gender: 'male'
};

//只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：
interface Person {
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
}
```
### 7. 数组类型
```ts
let fibonacci: number[] = [1, 1, 2, 3, 5];

let fibonacci: Array<number> = [1, 1, 2, 3, 5];
```
### 8. 常用的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等：
```ts
function sum() {
    let args: IArguments = arguments;
}
```
其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：
```ts
interface IArguments {
    [index: number]: any;
    length: number;
    callee: Function;
}
```
### 9. 函数的类型
```ts
//输入多余的（或者少于要求的）参数，是不被允许的：
function sum(x: number, y: number): number {
    return x + y;
}
sum(1, 2, 3);
// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.

sum(1);
// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.

//可选参数（可选参数必须接在必需参数后面）
function buildName(firstName: string, lastName?: string) {}

function push(array: any[], ...items: any[]) {}
```
### 10. 函数表达式
```ts
let mySum = function (x: number, y: number): number {
    return x + y;
};


let mySum: (x: number, y: number) => number = function (x: number, y: number): number {
    return x + y;
};

//用接口定义函数的形状
interface SearchFunc {
    (source: string, subString: string): boolean;
}
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1;
}
```
### 11. 重载
重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。
```ts
function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
```
TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。
### 12. 类型断言
类型断言（Type Assertion）可以用来手动指定一个值的类型。  
`值 as 类型`  
`<类型>值`
```ts
(window as any).foo = 1;


interface ApiError extends Error {
    code: number;
}
interface HttpError extends Error {
    statusCode: number;
}
function isApiError(error: Error) {
    if (typeof (error as ApiError).code === 'number') {
        return true;
    }
    return false;
}
```
### 13. 声明文件
```ts
export const name: string;
export function getName(): string;
export class Animal {
    constructor(name: string);
    sayHi(): string;
}
export enum Directions {
    Up,
    Down,
    Left,
    Right
}
export interface Options {
    data: any;
}

// types/foo/index.d.ts
declare const name: string;
declare function getName(): string;
declare class Animal {
    constructor(name: string);
    sayHi(): string;
}
declare enum Directions {
    Up,
    Down,
    Left,
    Right
}
interface Options {
    data: any;
}
export { name, getName, Animal, Directions, Options };

// types/foo/index.d.ts
export default function foo(): string;
```
### 14. 内置对象
Boolean、Error、Date、RegExp 等。   
Document、HTMLElement、Event、NodeList

## 进阶
### 1. 类型别名
类型别名用来给一个类型起个新名字。
```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    } else {
        return n();
    }
}
```
### 2. 元组
```ts
let tom: [string, number] = ['Tom', 25];
```
### 3. 类
TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。

public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的
private 修饰的属性或方法是私有的，不能在声明它的类的外部访问
protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的
```ts
class Animal {
  public name;
  // public name: string;
  // readonly name;
  public constructor(name) {
    this.name = name;
  }
}
let a = new Animal('Jack');
console.log(a.name); // Jack
a.name = 'Tom';
console.log(a.name); // Tom
```
```ts
class Animal {
  private name;
  public constructor(name) {
    this.name = name;
  }
}

let a = new Animal('Jack');
console.log(a.name); // Jack
a.name = 'Tom';

// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.
// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'.
```
```ts
class Animal {
  protected name;
  public constructor(name) {
    this.name = name;
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
    console.log(this.name);
  }
}
```
### 4. 抽象类
`abstract` 用于定义抽象类和其中的抽象方法。

首先，抽象类是不允许被实例化的,抽象类中的抽象方法必须被子类实现：
```ts
abstract class Animal {
  public name;
  public constructor(name) {
    this.name = name;
  }
  public abstract sayHi();
}
class Cat extends Animal {
  public sayHi() {
    console.log(`Meow, My name is ${this.name}`);
  }
}
let cat = new Cat('Tom');
```